import numpy as np                      
import matplotlib.pyplot as plt 
from scipy.linalg import solve 

# 1 
# загрузка данных из файла 

data = np.genfromtxt("data2.csv", delimiter = ";", skip_header = 1)

# проверка на пропущенные значения (NaN)
if np.isnan(data).any():
    data = data[~np.isnan(data).any(axis=1)] # если да, оставляем только те строки, где нет ни одного NaN

# разделяем данные 
x = data[:, 0]  # первый столбец — скидка
y = data[:, 1]  # второй столбец — прибыль


# формируем систему уравнений для полинома 2-й степени 

# выбираем 3 характерные точки из данных: начало, середина, конец
x_points2 = np.array([x[0], x[len(x)//2], x[-1]]) # скидки для 3х точек
y_points2 = np.array([y[0], y[len(y)//2], y[-1]]) # соответствующие прибыли

# составляем матрицу коэффициентов для системы линейных уравнений Ax = b:
# для полинома f(x) = a2*x^2 + a1*x + a0
# подставляем три выбранные точки, получаем три уравнения:
# [x1²  x1  1] [a2]   [y1]
# [x2²  x2  1] [a1] = [y2]
# [x3²  x3  1] [a0]   [y3]
A2 = np.array([
    [x_points2[0]**2, x_points2[0], 1],
    [x_points2[1]**2, x_points2[1], 1],
    [x_points2[2]**2, x_points2[2], 1]
])
b2 = y_points2  # вектор правых частей (прибыль)


# 2
# решаем СЛУ для нахождения коэффициентов полинома 

# solve(A, b) решает систему Ax = b, возвращает вектор [a2, a1, a0]
a2, a1, a0 = solve(A2, b2)
print("Коэффициенты квадратичного полинома:", a2, a1, a0)


# 3 
# вычисляем предсказанные значения для всех точек 

# подставляем все x в найденную формулу f(x) = a2*x^2 + a1*x + a0
y_pred2 = a2 * x**2 + a1 * x + a0


# 5
# считаем RSS 

# RSS = sum(yi - f(xi))^2
# чем меньше RSS, тем лучше модель приближает данные
rss2 = np.sum((y - y_pred2)**2)
print("RSS для полинома 2-й степени:", rss2)


# 6
# формируем СЛУ для полинома 3-й степени 

# для полинома f(x) = a3*x^3 + a2*x^2 + a1*x + a0
# нужно 4 точки (по числу коэффициентов)
x_points3 = np.array([x[0], x[len(x)//3], x[2*len(x)//3], x[-1]])
y_points3 = np.array([y[0], y[len(x)//3], y[2*len(x)//3], y[-1]])

# аналогично формируем матрицу коэффициентов
A3 = np.array([
    [x_points3[0]**3, x_points3[0]**2, x_points3[0], 1],
    [x_points3[1]**3, x_points3[1]**2, x_points3[1], 1],
    [x_points3[2]**3, x_points3[2]**2, x_points3[2], 1],
    [x_points3[3]**3, x_points3[3]**2, x_points3[3], 1]
])
b3 = y_points3  # прибыли для этих 4х точек

# решаем СЛУ (находим 4 коэффициента)
a3, a2_, a1_, a0_ = solve(A3, b3)
print("Коэффициенты кубического полинома:", a3, a2_, a1_, a0_)

# вычисляем предсказанные значения для всех x
y_pred3 = a3 * x**3 + a2_ * x**2 + a1_ * x + a0_

# считаем RSS для кубического полинома
rss3 = np.sum((y - y_pred3)**2)
print("RSS для полинома 3-й степени:", rss3)


# 8 
# сравнение моделей

# выбираем ту, у которой меньше RSS (лучше приближение)
if rss2 < rss3:
    print("\nЛучшая модель: квадратичный полином")
    best = (lambda x_val: a2 * x_val**2 + a1 * x_val + a0)
else:
    print("\nЛучшая модель: кубический полином")
    best = (lambda x_val: a3 * x_val**3 + a2_ * x_val**2 + a1_ * x_val + a0_)


# прогноз прибыли при скидке 6% и 8%
for discount in [6, 8]:
    # вычисляем значение полинома в заданной точке
    print(f"Прибыль при скидке {discount}% = {best(discount):.2f}")
    


# 9 
# средняя прибыль по всему файлу 
mean_profit = np.mean(y)
print(f"\nСредняя прибыль по всем данным: {mean_profit:.2f}")


# 4
# построение графиков

plt.figure(figsize=(10, 6))  # задаем размер графика (ширина × высота)
plt.scatter(x, y, color="blue", label="Исходные данные")  # точки исходных наблюдений
plt.plot(x, y_pred2, color="red", linestyle="--", label="Полином 2-й степени")
plt.plot(x, y_pred3, color="green", linestyle=":", label="Полином 3-й степени")
plt.title("Прибыль в зависимости от скидки") # заголовок графика
plt.xlabel("Скидка (%)") # подпись оси X
plt.ylabel("Прибыль") # подпись оси Y
plt.legend() # отображаем подписи линий
plt.grid(True) # включаем сетку
plt.show() # выводим график на экран

